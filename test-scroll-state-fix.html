<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scroll State Fix Test - WPEngine Staging Issue</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #2563eb;
            margin-bottom: 10px;
        }

        .alert {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .alert h2 {
            color: #92400e;
            font-size: 18px;
            margin-bottom: 8px;
        }

        .alert p {
            color: #78350f;
            font-size: 14px;
            line-height: 1.6;
        }

        .test-scenario {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .test-scenario h3 {
            color: #1e293b;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .test-area {
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .messages {
            height: 300px;
            overflow-y: auto;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            background: #fafafa;
            display: flex;
            flex-direction: column;
            gap: 10px;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            touch-action: pan-y;
        }

        .message {
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 80%;
            animation: slideIn 0.2s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            background: #F1F2F4;
            color: #2A2B2C;
            align-self: flex-end;
        }

        .message.bot {
            background: #2563eb;
            color: white;
            align-self: flex-start;
        }

        .message.streaming::after {
            content: '‚ñã';
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-secondary {
            background: #64748b;
            color: white;
        }

        .btn-secondary:hover {
            background: #475569;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .status {
            background: #f1f5f9;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
            font-family: monospace;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .fix-list {
            background: #eff6ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .fix-list h2 {
            color: #1e40af;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .fix-list ul {
            margin-left: 20px;
        }

        .fix-list li {
            color: #1e40af;
            margin-bottom: 6px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêõ WPEngine Staging Scroll Issue Test</h1>

        <div class="alert">
            <h2>Issue Description</h2>
            <p><strong>Problem:</strong> After a response finishes streaming, scrolling is locked/broken on mobile. Closing and reopening the chat fixes it.</p>
            <p><strong>Root Cause:</strong> Scroll event listener was lost when messages container was replaced during view transitions. Scroll state could also get stuck in streaming mode.</p>
        </div>

        <div class="fix-list">
            <h2>‚úÖ Fixes Implemented</h2>
            <ul>
                <li><code>resetScrollState()</code> - Utility to reset scroll state to clean defaults</li>
                <li><code>attachScrollListener()</code> - Utility to reattach scroll listener after DOM changes</li>
                <li>State reset called before each message send</li>
                <li>State reset when opening/closing widget</li>
                <li>State reset when starting new chat</li>
                <li><strong>Scroll listener reattached after view transitions (CRITICAL FIX)</strong></li>
                <li>30-second streaming timeout failsafe to prevent stuck states</li>
            </ul>
        </div>

        <div class="test-scenario">
            <h3>üß™ Test Scenario 1: Multiple Messages Without Close/Reopen</h3>
            <div class="test-area">
                <div id="messages1" class="messages">
                    <div class="message bot">Ready to test! Send multiple messages without closing.</div>
                </div>
                <div class="controls">
                    <button class="btn-primary" onclick="simulateStreaming(1)">Send Message 1</button>
                    <button class="btn-primary" onclick="simulateStreaming(1)">Send Message 2</button>
                    <button class="btn-primary" onclick="simulateStreaming(1)">Send Message 3</button>
                    <button class="btn-secondary" onclick="simulateViewTransition(1)">Simulate View Transition</button>
                    <button class="btn-danger" onclick="clearMessages(1)">Clear</button>
                </div>
                <div id="status1" class="status">Status: Ready</div>
            </div>
        </div>

        <div class="test-scenario">
            <h3>üß™ Test Scenario 2: Error During Streaming</h3>
            <div class="test-area">
                <div id="messages2" class="messages">
                    <div class="message bot">Test error recovery - state should reset even on errors.</div>
                </div>
                <div class="controls">
                    <button class="btn-primary" onclick="simulateStreaming(2)">Normal Message</button>
                    <button class="btn-danger" onclick="simulateError(2)">Simulate Error During Streaming</button>
                    <button class="btn-primary" onclick="simulateStreaming(2)">Try Message After Error</button>
                    <button class="btn-danger" onclick="clearMessages(2)">Clear</button>
                </div>
                <div id="status2" class="status">Status: Ready</div>
            </div>
        </div>

        <div class="test-scenario">
            <h3>‚úÖ Expected Behavior</h3>
            <div class="test-area">
                <ul style="line-height: 1.8; color: #334155;">
                    <li>‚úÖ Scroll works during streaming (auto-scrolls if at bottom)</li>
                    <li>‚úÖ Scroll works after streaming completes</li>
                    <li>‚úÖ Multiple consecutive messages don't break scrolling</li>
                    <li>‚úÖ View transitions don't break scrolling</li>
                    <li>‚úÖ Errors don't permanently break scrolling</li>
                    <li>‚úÖ No need to close/reopen to restore scroll functionality</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Simulate the chatbot's scroll state management
        class ScrollStateManager {
            constructor(containerId) {
                this.containerId = containerId;
                this.container = document.getElementById(`messages${containerId}`);
                this.statusEl = document.getElementById(`status${containerId}`);
                this.scrollState = {
                    isStreaming: false,
                    userHasScrolledUp: false,
                    scrollListener: null,
                    streamingTimeout: null
                };
                this.attachScrollListener();
            }

            resetScrollState() {
                this.scrollState.isStreaming = false;
                this.scrollState.userHasScrolledUp = false;
                if (this.scrollState.streamingTimeout) {
                    clearTimeout(this.scrollState.streamingTimeout);
                    this.scrollState.streamingTimeout = null;
                }
                this.updateStatus('State reset ‚úÖ');
            }

            attachScrollListener() {
                if (!this.container) return;

                // Remove existing listener
                if (this.scrollState.scrollListener) {
                    this.container.removeEventListener('scroll', this.scrollState.scrollListener);
                }

                // Create and attach new listener
                this.scrollState.scrollListener = () => {
                    if (this.scrollState.isStreaming) {
                        this.scrollState.userHasScrolledUp = !this.isScrolledToBottom();
                        this.updateStatus();
                    }
                };

                this.container.addEventListener('scroll', this.scrollState.scrollListener);
                console.log(`Scroll listener attached for container ${this.containerId}`);
            }

            isScrolledToBottom() {
                const threshold = 100;
                const position = this.container.scrollTop + this.container.clientHeight;
                const height = this.container.scrollHeight;
                return position >= height - threshold;
            }

            scrollToBottom(force = false) {
                if (this.scrollState.isStreaming && !force) {
                    if (this.isScrolledToBottom()) {
                        this.container.scrollTop = this.container.scrollHeight;
                    }
                } else {
                    this.container.scrollTop = this.container.scrollHeight;
                }
            }

            updateStatus(msg = null) {
                const atBottom = this.isScrolledToBottom();
                const streaming = this.scrollState.isStreaming;
                const scrolledUp = this.scrollState.userHasScrolledUp;

                this.statusEl.className = 'status';
                if (streaming) {
                    this.statusEl.className += ' error';
                } else if (msg && msg.includes('‚úÖ')) {
                    this.statusEl.className += ' success';
                }

                this.statusEl.textContent = msg || `Streaming: ${streaming}, At Bottom: ${atBottom}, Scrolled Up: ${scrolledUp}, Listener: ${this.scrollState.scrollListener ? 'Attached' : 'Missing'}`;
            }

            async startStreaming(text) {
                // Reset before starting (like the fix does)
                this.resetScrollState();

                this.addMessage('user', 'Test message');

                const botMsg = document.createElement('div');
                botMsg.className = 'message bot streaming';
                this.container.appendChild(botMsg);

                this.scrollState.isStreaming = true;

                // Failsafe timeout
                this.scrollState.streamingTimeout = setTimeout(() => {
                    console.warn('Streaming timeout reached');
                    this.resetScrollState();
                    this.updateStatus('Timeout reached - auto-reset ‚ö†Ô∏è');
                }, 30000);

                const words = text.split(' ');
                let accumulated = '';

                for (let i = 0; i < words.length; i++) {
                    accumulated += (i > 0 ? ' ' : '') + words[i];
                    botMsg.textContent = accumulated;
                    this.scrollToBottom();
                    this.updateStatus();
                    await new Promise(resolve => setTimeout(resolve, 80));
                }

                botMsg.classList.remove('streaming');
                this.resetScrollState();
                this.updateStatus('Streaming complete - scroll should work! ‚úÖ');
            }

            addMessage(type, text) {
                const msg = document.createElement('div');
                msg.className = `message ${type}`;
                msg.textContent = text;
                this.container.appendChild(msg);
                this.scrollToBottom(true);
            }

            simulateViewTransition() {
                this.updateStatus('Simulating view transition...');

                // Simulate replacing messages container (like transitionToView does)
                const oldContainer = this.container;
                const parent = oldContainer.parentElement;

                // Save messages
                const messages = Array.from(oldContainer.children);

                // Replace container
                const newContainer = document.createElement('div');
                newContainer.id = oldContainer.id;
                newContainer.className = oldContainer.className;
                parent.replaceChild(newContainer, oldContainer);

                // Update reference
                this.container = newContainer;

                // Restore messages
                messages.forEach(msg => newContainer.appendChild(msg.cloneNode(true)));

                // CRITICAL FIX: Reattach scroll listener
                this.attachScrollListener();

                this.updateStatus('View transition complete - listener reattached ‚úÖ');
            }

            clear() {
                this.container.innerHTML = '<div class="message bot">Cleared! Send a message.</div>';
                this.resetScrollState();
                this.updateStatus('Cleared ‚úÖ');
            }
        }

        const managers = {
            1: new ScrollStateManager(1),
            2: new ScrollStateManager(2)
        };

        async function simulateStreaming(id) {
            const longText = 'This is a test message that simulates streaming behavior. Each word appears one at a time. Try scrolling up during the animation to see how the smart scroll system works. If you scroll up it should pause auto-scrolling. If you scroll back to the bottom it should resume. After this completes you should be able to scroll freely without any issues.';
            await managers[id].startStreaming(longText);
        }

        async function simulateError(id) {
            managers[id].updateStatus('Starting streaming...');
            managers[id].scrollState.isStreaming = true;

            // Simulate starting to stream then hitting an error
            managers[id].addMessage('user', 'Error test message');

            await new Promise(resolve => setTimeout(resolve, 500));

            // Simulate error - state should reset
            managers[id].resetScrollState();
            managers[id].addMessage('bot', '‚ùå Error occurred! But scroll state was reset.');
            managers[id].updateStatus('Error handled - state reset ‚úÖ');
        }

        function simulateViewTransition(id) {
            managers[id].simulateViewTransition();
        }

        function clearMessages(id) {
            managers[id].clear();
        }

        // Initial status update
        managers[1].updateStatus('Ready - try sending multiple messages');
        managers[2].updateStatus('Ready - test error scenarios');
    </script>
</body>
</html>
